# Kubernetes Cluster Role, Cluster Role Binding and Certificate Signing Request

Kubernetes Cluster Role, Cluster Role Binding, and Certificate Signing Request (CSR) are all crucial components for enabling collaboration and teamwork within a Kubernetes environment.

1. Cluster Role: A Cluster Role defines a set of permissions that can be granted to users or groups within a Kubernetes cluster. It allows fine-grained control over what actions can be performed on various resources. By defining appropriate Cluster Roles, administrators can ensure that users have the necessary privileges to perform their tasks without granting excessive permissions.

2. Cluster Role Binding: Cluster Role Binding associates a Cluster Role with a user or group, thereby granting them the permissions defined in the Cluster Role. It establishes the link between users and the roles they are assigned, enabling access control and authorization within the cluster. Cluster Role Binding ensures that each team member has the appropriate level of access based on their role and responsibilities.

3. Certificate Signing Request (CSR): A CSR is a request generated by a user or a device to obtain a digital certificate from a Certificate Authority (CA). In the context of Kubernetes, CSRs are used to authenticate and authorize users or components within the cluster. By submitting a CSR, a user can prove their identity and request the necessary certificates to access the cluster resources. This ensures secure communication and authentication between different users and components.

Together, these components play a vital role in facilitating collaboration and teamwork within a Kubernetes environment. They enable administrators to define granular permissions, associate them with users or groups, and authenticate users through certificates. This ensures that team members can work together effectively, with the appropriate level of access and security.

![](/images/10-image01.png)

Kubernetes Cluster Role defines permissions for cluster-level operations, Cluster Role Binding binds those permissions to users or service accounts, and Certificate Signing Request is used to obtain certificates for securing communication within the cluster.

| Feature                   | Kubernetes Cluster Role | Cluster Role Binding | Certificate Signing Request |
|---------------------------|-------------------------|----------------------|----------------------------|
| Purpose                   | Defines permissions and access control for resources within a cluster | Binds a user or group to a cluster role, granting them the defined permissions | Requests a digital certificate from a certificate authority (CA) to verify the authenticity of a user or service |
| Scope                     | Applies to the entire cluster | Applies to a specific user or group | Applies to a specific user or service |
| Permissions               | Defines what actions can be performed on resources within the cluster | Grants permissions defined in the associated cluster role to the user or group | N/A |
| Relationship with Users   | Not directly associated with users | Binds users or groups to cluster roles | Used by users or services to request a certificate |
| Relationship with Roles   | Defines the permissions and access control for resources within the cluster | Binds users or groups to cluster roles, granting them the defined permissions | N/A |
| Relationship with Services | Not directly associated with services | Not directly associated with services | Used by services to request a certificate |
| Example                   | A cluster role can be created to allow read-only access to all pods within the cluster | A cluster role binding can be created to grant a specific user read-write access to pods within a namespace | A certificate signing request can be used by a service to request a certificate for secure communication |
| YAML Representation      | `kind: ClusterRole` | `kind: ClusterRoleBinding` | `kind: CertificateSigningRequest` |

## DOCKER-DESKTOP KUBERNETES CLUSTER
For demo purpose I will use Docker-Desktop kubernetes cluster. Please note that Docker-Desktop Kubernetes Cluster is not the same with KinD (Kubernetes in Docker). They both run locally and save us money by not necessarily running cloud compute but the main difference is Docker-Desktop can only provide one node while KinD can give multiple which is ideal to simulate controller and worker nodes for load balancing.

| Feature                 | Docker-Desktop Kubernetes Cluster | KIND (Kubernetes in Docker) |
|-------------------------|-----------------------------------|----------------------------|
| Installation            | Easy to install and set up        | Easy to install and set up |
| Cluster Management      | Provides a graphical user interface (GUI) for managing the cluster | Managed through command-line interface (CLI) |
| Resource Consumption    | Consumes more system resources due to the GUI | Consumes fewer system resources |
| Scalability             | Supports scaling up and down the cluster | Supports scaling up and down the cluster |
| Networking              | Provides built-in networking capabilities | Requires additional configuration for networking |
| Storage                 | Supports persistent storage through Docker volumes | Supports persistent storage through Docker volumes |
| Integration with Docker | Seamlessly integrates with Docker containers and images | Seamlessly integrates with Docker containers and images |
| Community Support       | Has a large and active community for support and troubleshooting | Has a growing community for support and troubleshooting |
| Platform Compatibility | Available for Windows and macOS | Available for Linux, macOS, and Windows |
| Customization           | Provides limited customization options | Provides more customization options |
| Deployment              | Suitable for local development and testing | Suitable for local development and testing |
| Production Readiness    | Not recommended for production environments | Not recommended for production environments |
| Documentation           | Well-documented with official documentation and tutorials | Well-documented with official documentation and tutorials |
| Nodes Available           | One | Multiple |

First, take a look at nginx-deployment.yaml file below which basically create a deployment and service of nginx which we will use as a sample to create another kubernetes authorization resources above.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
spec:
  selector:
    matchLabels:
      app: nginx
  replicas: 1
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx
        ports:
        - containerPort: 80
        resources:
         requests:
           cpu: 100m
           memory: 128Mi

---
apiVersion: v1
kind: Service
metadata:
  name: nginx
  labels:
    app: nginx
spec:
  ports:
  - name: http
    port: 80
    protocol: TCP
    targetPort: 80
  selector:
    app: nginx
  type: LoadBalancer
```

```sh
$ kubectl apply -f nginx-deployment.yaml
    deployment.apps/nginx created
    service/nginx created

$ kubectl get all
    NAME                         READY   STATUS              RESTARTS   AGE
    pod/nginx-6dd64cbf6b-fwgzh   0/1     ContainerCreating   0          4s

    NAME                 TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE
    service/kubernetes   ClusterIP      10.96.0.1       <none>        443/TCP        41h
    service/nginx        LoadBalancer   10.104.16.189   <pending>     80:31040/TCP   4s

    NAME                    READY   UP-TO-DATE   AVAILABLE   AGE
    deployment.apps/nginx   0/1     1            0           4s

    NAME                               DESIRED   CURRENT   READY   AGE
    replicaset.apps/nginx-6dd64cbf6b   1         1         0       4s

```

## USER AND CONTEXT CREATION
We can first generate a key using OpenSSL with the following command which basically created a file adam.key as below
```sh
$ openssl genrsa -out adam.key 2048
$ cat adam.key
    -----BEGIN PRIVATE KEY-----
    MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDQm+k1yy09uiLa
    ...
    ZxXGsJppD0yVJGpWmJSGyURH
    -----END PRIVATE KEY-----
```

Then we will generate Certificate Signing Request (CSR) as follow.<br>
The paramater  -subj: subject "/CN=adam" tells k8s the certificate name is adam.
From this step another file called adam.csr was created which has different content from adam.key

```txt
openssl req -new -key adam.key -subj "/CN=adam" -out adam.csr
$ cat adam.csr
    -----BEGIN CERTIFICATE REQUEST-----
    MIICVDCCATwCAQAwDzENMAsGA1UEAwwEYWRhbTCCASIwDQYJKoZIhvcNAQEBBQAD
    ...
    8QyPzGh0/+KD3oJ04iRlNOJCjsxtQLIfQlyqH3fKeYJ3rI4eyFQnX3Gf87f4GcM/
    K1aT+HjW5GttMvoKVcsIKMieEHXrHEq7
```

And we need to get a base64 format that is necesssary for the next step as follow, which also different.
```txt
 cat adam.csr | base64 | tr -d "\n"

    LS0tLS1CRUdJTiBDRVJUSUZJQ0FURSBSRVFVRVNULS0tLS0KTUlJQ1ZEQ0NBVHdDQVFBd0R6RU5NQXNHQ
    ...
    0tLS1FTkQgQ0VSVElGSUNBVEUgUkVRVUVTVC0tLS0tCg==
```

Next, we can download a yaml template from this [link](https://kubernetes.io/docs/reference/access-authn-authz/certificatesigning-requests/#create-certificatessigningrequest) and modify the "metadata name" and "spec request" as follow

```txt
$ cat adam-csr.yaml
apiVersion: certificates.k8s.io/v1
kind: CertificateSigningRequest
metadata:
  name: adam
spec:
  request: LS0tLS1C...0tLS0tCg==
  signerName: kubernetes.io/kube-apiserver-client
  expirationSeconds: 86400 # one day
  usages:
  - client auth
```

We can run it and we could see a new pending csr was created.

```txt
$kubectl apply -f adam-csr.yaml
    certificatesigningrequest.certificates.k8s.io/adam created

$ kubectl get CertificateSigningRequest
    NAME   AGE   SIGNERNAME                            REQUESTOR            REQUESTEDDURATION   CONDITION
    adam   39s   kubernetes.io/kube-apiserver-client   docker-for-desktop   24h                 Pending
```

To simplify the real world scenario where someone else has to approve this request (could not be the same person who created a request) I just would like to show the kubectl command on how to approve this request and how the status of the request changed from Pending into Approved,Issued like below.

```txt
$kubectl certificate approve adam
    certificatesigningrequest.certificates.k8s.io/adam approved

$ kubectl get CertificateSigningRequest
    NAME   AGE     SIGNERNAME                            REQUESTOR            REQUESTEDDURATION   CONDITION
    adam   4m26s   kubernetes.io/kube-apiserver-client   docker-for-desktop   24h                 Approved,Issued


$ kubectl get csr adam -o yaml
apiVersion: certificates.k8s.io/v1
kind: CertificateSigningRequest
metadata:
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: |
      {"apiVersion":"certificates.k8s.io/v1","kind":"CertificateSigningRequest","metadata":{"annotations":{},"name":"adam"},"spec":{"expirationSeconds":86400,"request":"LS0tLS1CRUdJTiBDRVJUSUZJQ0FURSBSRVFVRVNULS0tLS0KTUlJQ1ZEQ0NBVHdDQVFB...0tCg==","signerName":"kubernetes.io/kube-apiserver-client","usages":["client auth"]}}
  creationTimestamp: "2024-02-15T18:34:29Z"
  name: adam
  resourceVersion: "21364"
  uid: bb392955-6326-4a8d-ab07-7abc02745778
spec:
  expirationSeconds: 86400
  groups:
  - system:masters
  - system:authenticated
  request: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURSBSRVFVRVNULS0tLS0KTUlJQ1ZEQ0NBVHdDQVFBd0R6RU5NQXNHQTF...mNEdjTS8KSzFhVCtIalc1R3R0TXZvS1Zjc0lLTWllRUhYckhFcTcKLS0tLS1FTkQgQ0VSVElGSUNBVEUgUkVRVUVTVC0tLS0tCg==
  signerName: kubernetes.io/kube-apiserver-client
  usages:
  - client auth
  username: docker-for-desktop
status:
  certificate: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUM5VENDQWQyZ0F3SUJBZ0lSQUpKZmVVSitrVWtIWUl...9Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K
  conditions:
  - lastTransitionTime: "2024-02-15T18:38:52Z"
    lastUpdateTime: "2024-02-15T18:38:52Z"
    message: This CSR was approved by kubectl certificate approve.
    reason: KubectlApprove
    status: "True"
    type: Approved
```
 Now, we can generate the certificate from the CSR as follow

 ```txt
 $ kubectl get csr adam -o jsonpath={.status.certificate} | base64 --decode > adam.crt

$ cat adam.crt
    -----BEGIN CERTIFICATE-----
    MIIC9TCCAd2gAwIBAgIRAJJfeUJ+kUkHYIFGZ5sauukwDQYJKoZIhvcNAQELBQAw
    ...    
    60VDBhZv/hECROW7r9QAD8zX1M/sbCY5+9Lm0igRF2j535XGLvwYnG4=
    -----END CERTIFICATE-----
 ```

## SETUP USERS AND CONTEXTS
We will see the existing user like below and add a new one with config set-credentials command and finally review all the users again. The docker-desktop is a default user coming from Docker-Desktop Kubernetes cluster.

```txt
$ kubectl config get-users
NAME
docker-desktop

$ kubectl config set-credentials adam --client-key=adam.key --client-certificate=adam.crt --embed-certs=true
User "adam" set.

$ kubectl config get-users
NAME
adam
docker-desktop
```
and we can create a new context as follow
```txt
$ kubectl config get-contexts
    CURRENT   NAME             CLUSTER          AUTHINFO         NAMESPACE
    *         docker-desktop   docker-desktop   docker-desktop   

$ kubectl config set-context adam --cluster=docker-desktop --user adam
    Context "adam" created.

$ kubectl config get-contexts
    CURRENT   NAME             CLUSTER          AUTHINFO         NAMESPACE
            adam             docker-desktop   adam             
    *         docker-desktop   docker-desktop   docker-desktop   
```

## CLUSTERROLE CREATION
We can create a ClusterRole with get, list, create, update and delete access to the
resource of deployments.apps and pods by creating dev-cr.yaml as follow

```txt
$kubectl create clusterrole dev-cr --verb=get,list,create,update,delete --resource=deployments.apps,pods --dry-run=client -o yaml > dev-cr.yaml

$cat dev-cr.yaml
    apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRole
    metadata:
    creationTimestamp: null
    name: dev-cr
    rules:
    - apiGroups:
    - ""
    resources:
    - pods
    verbs:
    - get
    - list
    - create
    - update
    - delete
    - apiGroups:
    - apps
    resources:
    - deployments
    verbs:
    - get
    - list
    - create
    - update
    - delete

$ kubectl get clusterrole --sort-by=.metadata.creationTimestamp | grep dev-cr
$
$ kubectl apply -f dev-cr.yaml
$ kubectl get clusterrole --sort-by=.metadata.creationTimestamp | grep dev-cr
  dev-cr 
```

## CLUSTERROLEBINDING CREATION
We can also Create a ClusterRoleBinding to bind the ClusterRole to the user "adam" by creating dev-cr.yaml as follow

```txt
$kubectl create clusterrolebinding dev-crb --clusterrole=dev-cr --user=adam --dry-run=client -o yaml > dev-crb.yaml

$$ kubectl get clusterrolebinding --sort-by=.metadata.creationTimestamp | grep dev-crb
$

$kubectl apply -f dev-crb.yaml
  clusterrolebinding.rbac.authorization.k8s.io/dev-crb created

$ kubectl get clusterrolebinding --sort-by=.metadata.creationTimestamp | grep dev-crb
  dev-crb
```
